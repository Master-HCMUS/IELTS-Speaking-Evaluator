"""Transcription orchestration layer.

Tasks: TRN-1..TRN-6 (P05)
Spec Ref: Section 5.1 Transcription Handling.

Responsibilities:
  - Provide single entrypoint get_transcript(session_id, audio_path,...)
  - Apply optional normalization (casing, punctuation stripping placeholder, disfluency marker pass-through)
  - Merge word timings if provider returns overlapping/adjacent tokens.
  - Graceful fallback: on failure, returns minimal Transcript with error marker if allow_fallback.
"""
from __future__ import annotations
from pathlib import Path
from typing import Optional, List

from models.core import Transcript, WordTiming
from logging_util.structured_logger import logger
from storage.backend import StorageBackend, StorageError
from .transcriber import Transcriber, TranscriptionError


class NormalizationOptions:
    def __init__(self, lowercase: bool = True, strip_punct: bool = False):
        self.lowercase = lowercase
        self.strip_punct = strip_punct

    def apply(self, text: str) -> str:
        out = text
        if self.lowercase:
            out = out.lower()
        if self.strip_punct:
            # lightweight punctuation removal; keep apostrophes for contractions
            import re
            out = re.sub(r"[\.,!?;:\"]", "", out)
        return out


def _merge_words(words: List[WordTiming]) -> List[WordTiming]:
    """Merge adjacent identical words or fix zero/negative durations.

    (Task TRN-4) Ensures each word has end > start and merges duplicates generated by models.
    """
    if not words:
        return []
    merged: List[WordTiming] = []
    for w in words:
        if w.end_ms <= w.start_ms:
            w.end_ms = w.start_ms + 1  # minimal span
        if merged and merged[-1].w == w.w and w.start_ms <= merged[-1].end_ms + 50:
            # extend previous token window
            merged[-1].end_ms = max(merged[-1].end_ms, w.end_ms)
            if w.confidence is not None and merged[-1].confidence is not None:
                merged[-1].confidence = (merged[-1].confidence + w.confidence) / 2
            continue
        merged.append(w)
    return merged


class TranscriptionService:
    def __init__(self, backend: StorageBackend, transcriber: Transcriber, norm: NormalizationOptions | None = None):
        self._backend = backend
        self._transcriber = transcriber
        self._norm = norm or NormalizationOptions()

    def get_transcript(self, session_id: str, audio_path: Path, allow_fallback: bool = True) -> Transcript:
        """Main orchestration entrypoint (TRN-2, TRN-5).

        Flow:
          1. Transcribe audio via underlying transcriber.
          2. Normalize text (optional).
          3. Merge word timings.
          4. Persist transcript to storage.
          5. Return transcript.
        On failure: if allow_fallback returns minimal placeholder transcript.
        """
        try:
            raw = self._transcriber.transcribe(audio_path)
            merged_words = _merge_words(list(raw.words))
            norm_text = self._norm.apply(raw.text)
            final = Transcript(words=merged_words, text=norm_text)
            try:
                self._backend.save_transcript(session_id, final)
            except Exception as e:  # noqa: BLE001
                logger.error("transcript_persist_failed", session_id=session_id, error=str(e))
            return final
        except (TranscriptionError, FileNotFoundError) as e:
            logger.error("transcription_failed", session_id=session_id, error=str(e))
            if not allow_fallback:
                raise
            # fallback minimal transcript (Task TRN-5)
            fallback = Transcript(words=[], text="__TRANSCRIPTION_FAILED__")
            try:
                self._backend.save_transcript(session_id, fallback)
            except Exception:  # pragma: no cover
                pass
            return fallback


__all__ = [
    "TranscriptionService",
    "NormalizationOptions",
]
